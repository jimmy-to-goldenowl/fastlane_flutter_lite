# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane

xcodeproj = './swift.xcodeproj'
workspace = './swift.xcworkspace'
APP_IDENTIFIER = ENV["MATCH_APP_IDENTIFIER"]
TEAM_ID = ENV["FASTLANE_TEAM_ID"]
FIREBASE_CLI_TOKEN = ENV["FIREBASE_CLI_TOKEN"]

keychainName = ENV["MATCH_KEYCHAIN_NAME"]
keychainPassword = ENV["MATCH_KEYCHAIN_PASSWORD"]

def delete_temp_keychain(name)
  delete_keychain(
    name: name
  ) if File.exist? File.expand_path("~/Library/Keychains/#{name}-db")
end

def create_temp_keychain(name, password)
  create_keychain(
    name: name,
    password: password,
    unlock: true,
    default_keychain: true, 
    lock_when_sleeps: false,
  )
end

def ensure_temp_keychain(name, password)
  delete_temp_keychain(name)
  create_temp_keychain(name, password)
end

default_platform(:ios)

platform :ios do
  before_all do
  end

  lane :increment_build_number_manually do
    increment_build_number({
      xcodeproj: xcodeproj,
      build_number: latest_testflight_build_number(app_identifier: APP_IDENTIFIER) + 1
    })
  end

  desc 'Fetch certificates and provisioning profiles'
  lane :certificates do |options|
    ENV['PROVISIONING_PROFILE_SPECIFIER'] = "match " + (options[:release] ? "AppStore " : "Development ") + ENV["MATCH_APP_IDENTIFIER"]
    
    ensure_temp_keychain(keychainName, keychainPassword)

    match(
      app_identifier: APP_IDENTIFIER,
      type: (options[:release] ? "appstore" : "development"),
      readonly: true,
      keychain_name: keychainName,
      keychain_password: keychainPassword,
    )
    update_code_signing_settings(
      bundle_identifier: APP_IDENTIFIER,
      use_automatic_signing: false,
      path: xcodeproj,
      targets: "swift",
      build_configurations: (options[:release] ? "Release" : "Release"),
      code_sign_identity: (options[:release] ? "Apple Distribution" : "Apple Development"),
      profile_name: ENV["PROVISIONING_PROFILE_SPECIFIER"]
    )
  end

  desc "Setup and Build with options"
  private_lane :build do |options|
    puts("Fastlane - Currentdir: #{sh("pwd")}")
    
    disable_automatic_code_signing(path: xcodeproj)
    # increment_build_number_manually
    certificates(release: options[:release], profile_name: ENV["PROVISIONING_PROFILE_SPECIFIER"])
    # sh("flutter build ios --release --no-codesign")
    settings_to_override = {
      :BUNDLE_IDENTIFIER => APP_IDENTIFIER,
      :PROVISIONING_PROFILE_SPECIFIER => ENV["PROVISIONING_PROFILE_SPECIFIER"],
      :DEVELOPMENT_TEAM => TEAM_ID
    }

    build_app(
      workspace: workspace,
      scheme: "swift",
      export_method: (options[:release] ? "app-store" : "development"),
      # archive_path: "./build/Runner.xcarchive",
      # output_directory: "./build/Runner",
      xcargs: settings_to_override,
      export_options: {
        signingStyle: "manual",
        provisioningProfiles: { 
          APP_IDENTIFIER => ENV["PROVISIONING_PROFILE_SPECIFIER"]
        }
      }
    )

    # enable_automatic_code_signing(path: xcodeproj)
  end

  desc "Push a new beta build to TestFlight"
  lane :beta do
    build(release: true)
    # changelog_from_git_commits # this will generate the changelog based on your last commits
    # testflight(
    #   skip_waiting_for_build_processing: true
    # )

    delete_temp_keychain(keychainName)
  end

  desc "Push a new beta build to Firebase"
  lane :firebase do
    build(release: false)
    # firebase_app_distribution(
    #   app: "1:978524361958:ios:8433c15f3fed2da7cbd727",
    #   testers: "jimmy.to.goldenowl@gmail.com",
    #   release_notes: sh("git log -1 --pretty='%s'"),
    #   firebase_cli_path: "/usr/local/bin/firebase",
    #   ipa_path: "Runner.ipa",     
    #   firebase_cli_token: FIREBASE_CLI_TOKEN
    # )

    delete_temp_keychain(keychainName)
  end

end
